``````` This is my notes file for '30 Days to Learn Laravel by Jeffrey Way  ```````

* Lecture 01 *

    -> Setting Up Herd and starting a new laravel project. Problems I faced :
        -> Uncommenting Zip command in php.ini, installing an unzipping utility and adding its path to system variables, and running a local server on my system using 'php artisan serve' command because 'laravel-project.test' wasn't working in my browser.
        -> I was Facing 'Failed to listen at 127.0.0.1:<port_number>'. I resolved it by going into C:\Users\<user>\.config\herd\php84\php.ini\ . Change `variables_order = "EGPCS"` to `variables_order = "GPCS"`.

* Lecture 02 : Your First Route and View *

    -> Adding two route paths (i.e. /about & /contact) in the /routes/web.php and building corresponding rendering pages (view) in /resources/views/...

* Lecture 03 : Create a Layout File *

    -> update about.php, contact.php to 'about.blade.php' and 'contact.blade.php' . Think of Blade as an extra layer on top of php which gives you some goodies, some helper methods and some shortcuts. (like tailwind CSS on top of CSS)

    -> Make /views/Components/layout.blade.php and past the layout HTML (which is common to all pages) in that so we don't have to write same darn HTML in each web-page.

    -> We don't want to paste our basic html layout code in every page's file (home,about, contact). So we paste it in a layout file and the reference it as a custom html tag. Since our file name is layout, so to reference it we use:

        <x-layout>
            <h1> Content which is unique to every page </h1>
        </x-layout>

        use of word x is just to make the tag unique and making sure we aren't using already existing tag.

    -> In layout file, we must tell the file that we want to past some unique content in the corresponding page. So, we mark the space in the layout file using this code:

        <?php echo $slot ?>
        -> 'Slot' is a reserved keyword in Laravel.

        -> Since we are using Blade, so '{{ $slot }}' will be equivalent to <?php echo $slot ?>

	** HOME WORK **

    -> extracting nav link in a file :
        - extract nav link in a file /views/Components/nav-link.blade.php
        - use {{ $attributes }} in place of 'href=""', since we are going to make it dynamic and link will be unique for each page.

        ```laravel

	    ./project/resources/views/Components/nav-link.blade.php~
        <a {{ $attributes }}> {{ $slot }} </a>

	    ./project/resources/views/Components/layout.blade.php~
        and <x-nav-link href="/page-route"> Page Name </x-nav-link> in the layout file.

        ```
* Lecture 04 : Pretty Layout TailwindCSS *

    -> {{ $attributes }} can be 'href', 'id', 'class' etc.
    -> What to do if you have more than one slots to be filled dynamically.
        - suppose the variable name in the layout page is $heading. In the corresponding route page, you can write as

        <x-slot:heading> Variable Dynamic Name </x-slot:heading>

            -> In this way i.e. by using the name of the slot, we specify the slot we are going to target.

    -> Navigation Links are little different and usually more complex from ordinary anchor tags. For example, we show different color for an active nav. So, you must keep nav links in separate file to remove the complexity from general file.

* Lecture 05 : Style Active Nav Link *

    -> We are going to add some custom styling and some code to highlight the active link.

    * *     request()    * *
        -> we used a method 'request()'. This helper method is used to grab information about the "CURRENT REQUEST" .

        -> This helper method has another method 'request()->is('expression')' which takes an expression and tells if the given expression matches the current page.
            -> request()->is('about') will return true if we are on 'about' page.

    * *     Aria Current     * *

       aria-current="page"
       -> This HTML attribute is used by screen readers, and it tells the user who has vision impairment whether the active nav link is current page or not.

    * *     Attributes and Props     * *

        Attributes -> refer to HTML attributes like 'id', 'class', 'href' etc.

        Props (Property) -> is anything that is not an attribute. You must know about them so not to include them as attribute of a tag.
            -> If you have a prop of name 'active' like :
            <a href="#" id="foo" active="uh-oh">
               now you have an anchor tag with an attribute 'active'. And that doesn't make sense. So Props should be distinguishable from HTML attributes.

        -> The attributes are rendered with the html page and can be seen when you inspect the page, however you can not see the props when you inspect a webpage using developer tools.

    * *     Blade Directives     * *

        -> Directives in Blade start with '@'.
        -> Directives can be @dump, @foreach, @if, @Props and
        -> @props directives are usually initialized on top in a file .
        -> They are ultimately compiled down to Vanilla PHP echo statements or function calls.

        -> Props (properties) are usually declared as array. If we don't declare Props, browser will render them as normal HTML attributes. (you can confirm by inspecting the webpage).
        -> props are passed as variables.

            @props(['active' => false])

            <a $active >Home</a>

        -> Must initialize props with some value so if anything fails, that default value is used.

        -> With laravel or blade, sometimes false is treated as "false" i.e. expression false is treated as string false.
        How to solve this?
        Put a semicolon : before a prop to indicate that the given value is an expression and not the string like:

            <x-nav-link href="/" :active="false">Home</x-nav-link>

        -> You can use PHP directive to execute php code as:

            @php
                // some php code
            @endphp

        * *     HOME WORK     * *

            -> creating a new 'type' props and apply if-statement if the type is button or anchor tag. Code for homework

                @props(['active' => false,
                    'type' => 'a'
                ])

                @if($type === 'a')
                    <a {{ $attributes }}  class=" {{ $active ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white' }} rounded-md px-3 py-2 text-base font-medium " aria-current=" {{ $active ? 'page' : 'false' }} ">{{ $slot }}</a>
                @else
                    <button {{ $attributes }}  class=" {{ $active ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white' }} rounded-md px-3 py-2 text-base font-medium " aria-current=" {{ $active ? 'page' : 'false' }} "> {{ $slot }} </button>
                @endif


* Lecture 06: View Data and Route Wildcards *

    -> In routes file, you can pass an array to the 'view()' along with the route. And, then you can access that array of variables in corresponding view file.

    ``` laravel

        ./routes/web.php
        Route::get('/', function () {
            return view('home', [
                'greeting' => 'Yo',
                'name' => 'Larry Nickolas'
            ]);
        });

        ./resources/views/home.blade.php
        <h1> {{ $greeting }} from the Welcome page. My name is {{ $name }} </h1>

    ```

    ->  Let's do something complex, suppose we have to list down jobs on our home page. So we can pass an array which will contains jobs and each job will have properties like 'Job Title' and 'Salary' etc.

    ``` laravel

    Route::get('/jobs', function () {
        return view('jobs', [
            'jobs' => [
                [
                    'id' => 1,
                    'title' => 'Director',
                    'salary' => '$50,000'
                ],
                [
                    'id' => 2,
                    'title' => 'Programmer',
                    'salary' => '$10,000'
                ],
                [
                    'id' => 3,
                    'title' => 'Teacher',
                    'salary' => '$40,000'
                ]
            ]
        ]);
    });


    ./resources/views/jobs.blade.php
            @foreach( $jobs as $job)
                    <li><strong> {{ $job['title'] }} : </strong> Pays {{ $job['salary'] }}</li>
            @endforeach

    -> Let's change the about page to the job page and shift this job listing to that and make our home page simple and clean.
    -> We need to change 'about.blade.php' to 'jobs.blade.php', change the nav-link in the 'layout.blade.php' file. tweak the view method in the ./routes/web.php to include the 'jobs[]'.
    -> 'about' page is now converted into 'jobs' page.

    * *     Routing to Specific Job Page    * *

        -> We are now going to create a specific page for each job. For that, we have included 'id' as property so each job is identifiable, and we can route to that specific job page using '/jobs/{id}'

        -> Turn the list items on jobs page into links using anchor tags.

        * * *   How Do We Create a Route that Listens for /jobs/<some_dynamic_value> ?  * * *

            -> Let's create a route in /web.php

            ```

            Route::get('/jobs/{id}', function ($id) {
                dd($id);
                return view('contact');
            });

            ```
            -> Laravel has cool thing. It will automatically detect that if something is enclosed in curly braces, it is some 'wildcard' character, and then you can pass it to any function to use it as you like.

            -> now if you put url example.test/jobs/1
                => dd($id) will give you value 1.
            -> likewise for 2 and 3.

            -> notice {id} was a wildcard, laravel did all the work of grabbing it, isolating it and then passing to the callback function/closure.

        * * *   Create a Route for Each Job Page  * * *

            -> We can do this by passing all the jobs to the callback function in the Route::get() and then return the view where $id will be equal to user requested job id.

            -> instead of running a foreach loop on each array item, leverage Laravel framework and use Arr::method() which is gonna give a number of methods to be run on array items.

            -> use the first() method to find the first item in the array which matches the given criteria

                ```

                $job = \Illuminate\Support\Arr::first($jobs, function($job) use ($id) {
                       return $job['id'] === $id;
                });

                // load the corresponding view
                return view('job', ['job' => $job]);

                ```

                OR

                ```

                $job = \Illuminate\Support\Arr::first($jobs, fn($job) => $job['id'] == $id);

                // load the corresponding view
                return view('job', ['job' => $job]);

                ```
            -> This code says, look in the $jobs array, grab each item as $job and return true if the value of 'id' property of that job equal to given value of the id.

            -> Create a corresponding job.blade.php and leveraging $job variable, print the job details

            -> href="" for the job page will become

            ``` /jobs.blade.php

            <ul>
                @foreach( $jobs as $job)
                        <a href="/jobs/{{ $job['id'] }}" class=" hover:underline">
                            <li><strong class="text-blue-500"> {{ $job['title'] }} : </strong> Pays {{ $job['salary'] }}</li>
                        </a>
                @endforeach
                </ul>

            ```


* Lecture 07: Auto loading and Models *

    -> In the previous lecture, we did the duplication of 'jobs' array in two routes (i.e. '/jobs' and '/job') in '/web.php' file. Ofc, duplication is not good in code. We are going to solve this issue incrementally.

    1st Solution:
        -> declare the 'jobs' array in global scope and then use it in your functions as.

        ``` web.php

        $jobs = [
            // jobs array
        ]


        Route::get('/jobs', function () use ($jobs) {
            return view('jobs', [
                'jobs' => $jobs
            ]);
        });


        Route::get('/jobs/{id}', function ($id) use $jobs {

            $job = Arr::first($jobs, callback: fn($job) => $job['id'] == $id);
            return view('job', ['job' => $job]);
            });

    2nd Solution:

        -> Extract the array and place it in a class, and then we can access the array using a public method of the class.

        ``` web.php

        class Jobs{
            public static function all(): array
                // return [ //array containing arrays of jobs]
        }

        # notices the ': array' after function declaration. This is to specify the return type of the function

        And then access it as :

            'job' => Job::all()
            and
            $job = Arr::first(Job::all(), callback: fn($job) => $job['id'] == $id);


    * *     Model - View - Controller (MVC)   * *

        USER -- uses --> CONTROLLER -- manipulates --> MODEL -- updates --> VIEW -- sees --> USER -- uses -->

        -> View : presentation layer
        -> Controllers: Handle logic and act as an intermediary between the Model and the View.

            -> It receives information from the user, process it (using models), and then return a response by rendering a view or redirecting to another page.
            ->Like in 'web.php', we define routes, and then we define a function that handles that route is a controller.

        -> Model: Represents data and  the business logic tier of your application.
            -> Models are used to interact with database and define relationship between tables.

            -> In case of Job Board Platform:
            -> Think of all the behaviors associated with the job. For example:
                => What are the rules for creating a job?
                => Can jobs be marked as opened or filled? What happens when a Job is filled?
                => This does account for how do you store the jobs, do you write them to a file?
                => How to remove or archive a Job?

            -> All of the above stuff can be encapsulated under the umbrella of MODEL.

            -> Now we are going to put 'Job' class (which we made in the previous lesson) into our Model directory.

    * *     Namespaces in Laravel/PHP   * *

        Namespaces are used to organize and group classes, functions, or constants to avoid naming conflicts.
        For example, if you have two files with same name 'User', you can place them in different namespaces to avoid conflicts.

    * *     Making a new function find()    * *

        -> How about if we extract the code to find the job with the given id and encapsulate it into a 'find()' method of job class? We're going to do that

        ```Job.php

            public static function find(int $id): array
                {
                    return Arr::first(static::all(), callback: fn($job) => $job['id'] == $id);
                }

        ```

        -> and just call that find() in web.php as :

        ``` web.php

            Route::get('/jobs/{id}', function ($id) {
                // grab the job which has id equals to the user requested id
                $job = Job::find($id);

                // load the view
                return view('job', ['job' => $job]);

            });

        ```


    * *     Should We Declare Datatypes     * *

        -> In case of errors, they'll point to a place where things are potentially easy to handle. And won't direct you to confusing parts of the code.
        -> in simpler words, points to the root cause where things will be comparatively easy to handle.

    * *     Declare Unhappy Path    * *

        -> Suppose user access a job with id which is not in our database, we must show user a 404 Page-Not-Found errors page.


* Lecture 08: Introduction to Migrations *

    -> .env file in your project directory is where your Preferences, passwords, database information is saved.
    -> Artisan in a Laravel Herd project is a powerful CLI tool used for tasks like code generation, database migrations, testing, cache management, and more.

    -> If you didn't create project using CLI, you might don't have the file './database/database.sqlite'. You can run following command to create a new database file:
        php artisan migrate

    * *     Connect to a Database     * *

        -> You can do this using CLI.
        -> If you want to do this using a GUI:
            -> install TablePlus -> create an SQLite connection -> give database name -> connect to the database file in your project directory -> connect

        -> The logic to create database tables is locked in PHP. When you create the database or run 'php artisan migrate', it runs the migrations stored in './database/migrations/*.php'. You can think of the files in this directory as Blueprints for table. If you make changes to files in this directory, you'll need to "run migrations" in order to display those changes in the database. You can add, reset, rollback changes using migrations (like version control).


    * *     Migrations     * *

        -> Consider if your team member will have to construct a database same as yours. It'll be a nightmare if the database is big. One little mistake would cost a lot. Migration solves a big issue.
            -> You just need to share these Migration files in '/database/migrations/*.php' with your teammate, and he just needs to run a single command to generate a database same as yours. The command is
                ```php artisan migrate```

        -> You can have migration to drop a table, or to create a table, or to add a couple of columns to the table.

        -> # # THINK OF MIGRATIONS AS ACTIONS YOU WANT TO PERFORM ON DATABASE. # #

        -> To list down command related to database, use:
            php artisan

            * * *   Making Changes to Migrations    * * *

                -> in 'create_users_table.php', in users table, change the name to first_name and add another column of last_name.

                -> If you change anything in migration files, run the command to make changes effective:
                    php artisan migrate:fresh

                    # This will drop all the tables and construct them from scratch according to changed 'Migration' file

                -> There's an issue with SQLite, it won't refresh until you close the connection and start the connection again.

            * * *   Creating a Job Listings Table    * * *

                -> Run the command:
                    php artisan make:migration

                -> set the table name to create_job_listings_table
                -> It will create a migration file in the /migrations.
                -> This file will have two Methods i.e. 'up' and 'down'. 'up' is for applying any operation,  adding things and removing things.
                -> 'up()' is for doing the thing and 'down()' is for undoing the thing.

                * * * *     Creating new columns    * * * *

                    ->add two columns in the job_listings table :
                        $table->string('title');
                        $table->string('salary');

                    -> run the following to make changes effective:
                        php artisan migrate

                        # This will migrate only the new changes from Blueprint(i.e. migrations file) and to the table

                    -> Populate data we were hard coding manually into the database 'job_listings' table.


* Lecture 09: Meet ELOQUENT *

    -> Laravel ORM is called Eloquent. An ORM is 'Object-Relational Model'. It helps to interact with database in object-oriented way.
    -> Eloquent automatically writes the PHP code you write into SQL queries. Helps you by not letting you write complex SQL queries.
    -> Eloquent maps a row in your database table into a PHP Object. Thus, makes handling data easier for you.

    * *     How to convert a Class into Eloquent Mode   * *

        -> import the Eloquent class:
            use \Illuminate\Database\Eloquent
        -> change the class name to:
            class Jobs extends Models{}

    -> Eloquent relies heavily on 'convention over configuration'.
    -> The Eloquent model name or class name should be 'singular form' of your table name. For example, if your table name in the database is "comments", your Eloquent model name or class name should be 'Comment'. Similarly, if your table name in database is 'posts', your Eloquent model name should be 'Post'.

    -> If your Eloquent Model name is Jobs and your table name is job_listings. You can do:
        1st -> change the model name to JobListing
        2nd -> in class, you can declare this
            protected $table = 'job_listings';

    -> show the jobs on the page using Job::all() as:

        ``` web.php

            use App\Models\Job;

            Route::get('/', function () {
                $jobs = Job::all();

                dd($jobs);

            //    return view('home');
            });

        ```

        -> In order to grab first job, use '$job[0]';
        -> In order to grab first job's any specific property, use '$job[0->title]';


        -> Get rid of the above route, and restore to original home route.

    -> Because of 'Job::all()' in our jobs view. The jobs will be listed down but this time they are being fetched from database, and we don't have to hard code them.

    * *     PHP Artisan Tinker   * *

        -> `php artisan tinker`
            ->this command will give you a playground shell to test your code, make and verify variables, create tables, users.

        -> in tinker, run this:
            > App\Models\Job::create(['title' => 'Acme Director', 'salary' => '$1,000,000')];

        -> Laravel will give you MassAssignmentException.
            > Mass Assignment is practice of assigning values to multiple model attributes at once, typically through an array.
            -> Let's dig into that. Usually it's in hands of users to update values such as title or salary. We believe users are malicious. If a user requests to change the title of a post and somehow tweak the form request to change the author-id of the post or admin status of a user or admin. That can be catastrophic. To avoid this, Laravel by-default protects you from assigning values to the attributes that are not explicitly allowed for mass assignment.
            -> Laravel protects you from accidentally assigning values to attributes that shouldn't be changed directly by the user, such as sensitive fields like password, is_admin, or id.
            -> You can either turn this feature off or do the following:

                -> explicitly allow attributes to be mass assigned:
                    ```

                        class Jobs extends Models{
                            $protected $fillable = ['title', 'salary'];
                        }

                    ```

                    -> Now, if the user tries to change the id, the request will be ignored.
                    -> close the tinker, re-open it and re-run the command to create a new job and now it works.

                    -> inspect all jobs
                        ``` App\Models\Job::all(); ```

                    -> to find a specific record in the database table. (the record must have a unique identifier)
                        ``` App\Models\Job::find(id); ```

                    -> to delete the job:
                        $job = App\Models\Job::find(id);

                        $job->delete();

    * *     Creating Models and Migration using php artisan   * *

        -> ` php artisan make:model <model-name> `
            -> this command will create a new Model in the /Models/ .

        -> ` php artisan make:model <model-name> -m `
            -> this command will create a new Model in the /Models/  with corresponding Migration.



* Lecture 10: Model Factories *

    -> Use Factory Models to quickly scaffold example data for purpose of both testing and preparing the local environment.

    -> Given we say "What if we have 10 users", well Factory is used to generate those users quickly.

    -> In Models, we have a trait 'use HasFactory'. This gives a lot of methods to the classes and is used to generate factories.

    -> UserFactory.php  => factory to create many users.

    * * Create Fake User using User.php Model and UserFactory.php factory * *

        -> in 'UserFactory.php' change the name to first_name and fake()->name() to fake()->firstName(), same for last name
        -> ``` php artisan tinker

            \App\Models\User::factory()->create()
            OR
            \App\Models\User::factory(10)->create()    // it's gonna create 10 fake users


    * * Create JobFactory factory corresponding to Job Model * *

        -> run following command to create a factory 'JobFactory' :
            ``` php artisan make:factory JobFactory ```

            # Laravel is smart enough to understand and map JobFactory to corresponding Job Model.

        -> Don't forget to add user HasFactory attribute in './app/Models/Job.php'

         ```
            use \Illuminate\Database\Eloquent\Factories\HasFactory;

            class Job extends Model {
                use HasFactory;
            }

          ```

         -> Change the factory file according to the database table. For example, our database table has two columns i.e. title, and salary. fill those fields with some data (either manually or using faker API i.e. fake()) as :

         ./database/JobFactory.php
         ```

            public function definition(): array
                {
                    return [
                        'title' => fake()->jobTitle(),
                        'salary' => '$50,000'

                    ];
                }

         ```

            # added title and salary manually


    * * Toggle state of a factory * *

        -> In UserFactory, there's a method called 'unverified()' which set the 'email_verified_at' column to null. If you want to toggle the state, use this method as part of your create command

            ``` \App\Models\User::factory()->unverified()->create() ```

    * * Create new State/Factory of a factory * *

        -> Suppose in UserFactory.php, you have an admin attribute which is by-default set to false. You can change it to true by defining a method for it. The code of the method is below. Also, don't forget to include 'admin' attribute in definition.

    ``` ./database/factories/UserFactory

        public function admin(): static
            {
                return $this->state(fn (array $attributes) => [
                    'admin' => true,
                ]); //   \App\Models\Job::factory()->admin()->create()  this will set the admin state to true
            }

    ```

    * * Create new Employer Table * *

        -> Let's introduce emloyer_id as foreign key to our job listings table, so each job has a corresponding employer_id
        -> create an Employer Model with corresponding Migration:
            -> php artisan make:mode Employer -m

            -> add employer_name attribute to employer table schema in  and introduce $table->unsignedBigInt('employer_id') in job listings table schema in '/migrations/'.

            -> while adding foreign keys, make sure the types of the foreign keys are identical (i.e. in job listings table and in employer table)

            -> two methods to introduce foreign key

                (i) $table->unsignedBigInt('employer_id');
                (ii) $table->foreignIdFor(\App\Models\Employer::class);

            -> ``` php artisan migrate:fresh ``` to drop all tables and build them again from scratch

            -> Since you had added 'employer_id' to schema, you have to include it in definition in 'JobFactory.php' and initialize it with fake()->method() or some dummy hard coded data.

                'employer_id' => Employer::factory(),

                # notice we didn't hardcode it but rather this code says, whenever we generate a job, create a corresponding relationship like employer.

                -> Delete the Employer mode because we didn't generate corresponding factory and run this command

                ``` php artisan make:mode Employer -f ```

                # -f to generate corresponding factory. Since we already generated the corresponding migration so we didn't need to generate it again.

                 -> in EmployerFactory.php add this attribute to the definition:
                    'name' => fake()->company();

                 -> In tinker, run this command to generate 10 jobs with corresponding employer Id:
                    ```  \App\Models\Job::factory(10)->create() ```

* Lecture 11: Two Key Eloquent Relationship Types *

    -> In last lecture, we introduce 'employer_id' as a foreign key in the 'Job' table. We weren't able to access Employer information through the job which belongs to that specific Employer.
    -> Seems like 'Eloquent Relationship' can help us in that.
    -> Think about what kinda of relationship a specific job has with employer? 'A Job belongs to an Employer'. 'belongsTo()' is the key.

    * * Access Details of Employer from Job * *
        -> Let's declare a function in Job Model to access information of Employer using Job that belongs to that user.

        ``` App\Models\Job.php
                class Job extends Models{
                    // other jargon code

                    public function employer(){
                        return $this->belongsTo(class_name::class);
                    }
                }  // class_name in this case is 'Employer'


            -> now open tinker, grab the first job from the job_listings table
                > $first_job = App\Models\Job::first();
                > $first_job->employer;

                # it'll give the details of Employer to whom the job belongs to.
                # Notice we are accessing it as a property (i.e. ->employer) not as a method ( ->employer()), Laravel is smart enough to know it's a method and accesses that.

                -> How 'foreign id' is helping us in that? when we run this command :
                    ``` $first_job->employer; ```
                an SQL query is being in run in the background which says, SELECT FROM EMPLOYER TABLE WHERE ID=1;

    * * Access Jobs listed by an Employer * *

        -> now think the reverse of listing details of employer using job. Can we list all the jobs listed by an employer? Not Yet.
        -> It seems we need a method 'job()' in 'Employer.php' class that's going to return all the jobs listed by an employer.
        -> Think about what's the relationship between Employer and Jobs. An employer can create many jobs. So, AN EMPLOYER HAS MANY JOBS. hasMany it is.

        ``` ./app/models/Employer.php

            class Employer extends Model
            {
                /** @use HasFactory<\Database\Factories\EmployerFactory> */
                use HasFactory;

                public function jobs(){
                    return $this->hasMany(Job::class);
                }
            }

        -> now in tinker playground:
            $employer = App\Models\Employer::first();  // or you can give any id
            $employer->jobs;

            # it might give you a collection of jobs

        ```

    -> Let's find out about more Relationships

        -> I created
            * Post Model with PostFactory and corresponding posts migrations file.
            * Comment Model with CommentFactory and corresponding comments migrations file
            * Introduced 'title', 'body' column in posts migrations schema and 'body' column in comment migrations schema and also to the corresponding factories files.
            * Introduced post_id as foreign key in Comment migrations file and factory file
            * Created 'hasMany()' relationship between Post and Comments, and 'belongsTo()' relationship between Comment and Post by defining method for each task in corresponding Models (Post.php & Comment.php).


* Lecture 12: Pivot Table and BelongsToMany Relationships *

    -> We'll need some kind of pivot table to connect tags with the job. We are going to do that in this lesson:
    -> We have Job table, we make Tag table, and then we also need some kind of connecting table i.e. pivot table where we can store the tag_id and job_id.
    -> In this pivot table, we can store
        'job_id = 1' --> 'tag_id = 5'
        'job_id = 5' --> 'tag_id = 7'
        'job_id = 2' --> 'tag_id = 9'

    * *     Creating a Tag Model, factory, migrations     * *
        -> introduce 'name' to the tag migrations schema
        -> you can create a brand-new migrations file for pivot table, but there are no hard and fast rule for that, you can create a schema call in tag table migrations

        ```_create_tags_table.php
            in the up function, one schema call will be to build tag tables while other will be to build 'job_tag' i.e. our own pivot table.
             -> Pivot table mostly contains foreign ids.

            public function up(): void
                {
                    Schema::create('tags', function (Blueprint $table) {
                        $table->id();
                        $table->string('name');
                        $table->timestamps();
                    });

                    Schema::create('job_tag', function (Blueprint $table) {
                        $table->id();
                        $table->foreignIdFor(\App\Models\Job::class, 'job_listing_id');
                        $table->foreignIdFor(\App\Models\Tag::class);
                        $table->timestamps();
                    });
                }

                # notice the argument 'job_listing_id' which is actually the column name for which the id will be generated. We want to be explicit that the id should be generated for 'job_listings' and not for 'job' table which laravel gives by-default.

        ```
        * * *   Constraints     * * *

            -> At this point, if we associate a 'tag' with a 'job' and then delete the 'tag', the entry in the 'job_tag' will be there (an orphan) because. That record will point to a 'tag' that is no longer in the system To make the changes Cascade, we'll need to implement constraints.

            -> let's introduce constraints for job_tag table in migrations file and also code to drop 'job_tag' table

            ``` tags table migrations ```

                in up method:

                    $table->foreignIdFor(\App\Models\Job::class, 'job_listing_id')->constrained()->cascadeOnDelete();
                                $table->foreignIdFor(\App\Models\Tag::class)->constrained()->cascadeOnDelete();

                in down method:

                    public function down(): void
                        {
                            Schema::dropIfExists('tags');
                            Schema::dropIfExists('job_tag');
                        }

                -> run ``` php artisan migrate:rollback
                       ``` php artisan migrate


            -> These are Laravel side constraints yet. In laravel, these constraints are turned on by-default (You can turn them off in .env file).  To implement the constraints, we need to enable the foreign constraints on SQLite by running this query:

                ``` PRAGMA foreign_keys=on ```

                -> Now, if you delete a tag, it'll automatically delete the tag associated record in 'job_tag' table.
                -> Same is true if we delete the referencing job.

        * * *   belongsToMany Relationship     * * *

            -> We have two Models, Job and Tag but there's no relationship between them yet. Think about what relationship Tags have with job? Tag 'belongsTo' a job but 'hasMany' jobs associated with it. So, tag belongsTo a job but not exclusively. So, 'belongsToMany' is the relationship. Now the relationship in both the Model files ( 'Job.php' and 'Tag.php' ) is defined as (respectively) :

            ``` Job.php

                 public function tags() {
                         return $this->belongsToMany(Tag::class);
                     }  // $job->tags

            ``` Tag.php

                 public function jobs() {
                         return $this->belongsToMany(Job::class);
                     } // $tag->jobs

            ```
            # This will still throw exception,  issue: you know who have a Job class (Job.php) but the related table name is 'job_listings'. We create instance of Job class, Laravel will look for column 'job_id' which is default. In our case, this column name is 'job_listing_id'. So we need to be explicit about column:

            ``` Job.php

                 public function tags() {
                     return $this->belongsToMany(Tag::class, foreignPivotKey:'job_listing_id');
                 }

            ```
            -> Run this in tinker:
                $job = App\Models\Job::find(9)
                and then
                $job->tags  // lists tags associated to the job with id '9'

            -> If you want to get the Jobs associated with a tag, you'll need to include 'relatedPivotKey' in the 'jobs()' method defined in 'Tag.php'

                public function jobs() {
                        return $this->belongsToMany(Job::class, relatedPivotKey: 'job_listing_id');
                }

                -> Run this in tinker:
                    $tag = App\Models\Tag::find(9)
                    and then
                    $tag->jobs  // lists jobs associated to the tag with id '1'

            * * * *     Attach a Tag to a Job       * * * *

                -> we have tag with id '1' in $tag. Let's attach it to the job with id '7'. For this we'll need to access 'jobs' as method 'jobs()' rather than as property 'jobs'.

                    ``` $tag->jobs()->attach(<id_of_job)
                        OR
                        $tag->jobs()->attach(App\Modes\Job::find(<id_of_job>)

                        # you'll notice the changes will not reflect if you run $tag->jobs. It's because the previous collection of jobs associated to the tag is still in the memory because '$tag->jobs' is not performing any new SQL query. You can solve this by
                            -> (i) fetching the $tag again by running $tag = App\Models\Tag::find(9);

                            -> (ii) running a brand-new SQL query as:
                                $tag->jobs()->get();

                        -> In this way, you'll get the updated records.

                        -> to pluck the single attribute from each job of the collection
                            $tag->jobs()->get()->pluck('title');


    * * Homework * *


* Lecture 13 : Eager Loading *

    -> Starts with styling the job listing with turning list into clickable long cards.
    -> Display the details of the employer on the job listing using this :
        ``` {{ $job->employer->name }} ```

    * *     Lazy Loading  (N+1) Problem      * *

        -> It is an optimization technique also known as on-demand loading. Instead of loading the whole web-page, lazy-loading loads only the content that's immediately necessary. The remaining content is loaded as the user interacts with the page.
            Example: Infinite scrolling where more content is loaded as the user goes down the page.
            -> Lazy Loading saves the resources. But it can cause performance issues if you are not thoughtful about it.

        -> Every time you want to fetch data from database, a query runs behind the scenes. If you want to fetch 100 records, 101 queries will be run. This is called N+1 Problem.
        -> N+1 problem arises when database queries are run using loop.

        -> Fetch the 'Laravel Debugbar' using the following command :
            ``` composer require barryvdh/laravel-debugbar --dev ```


    * *     Eager Loading      * *

        -> 'with()' eager loading, you can fetch all the records of the database with a single query. We just need to use "with('<relationship_with')". Change job route to:

            ``` web.php

                Route::get('/jobs', function () {
                    $jobs = Job::with('employer')->get();

                    return view('jobs', [
                        'jobs' => $jobs
                    ]);
                });

            ```
            # you'll notice the query count (which was 8) has now been reduced to 2.

            # $jobs = Job::all();   // Lazy loading
            # $jobs = Jobs::with('employer')->get();  // Eager Loading

            -> With eager loading, if we have fetched 100 records from the database, we'll have only 2 SQL queries.


        -> Lazy Loading OR Eager Loading : Simply Your Preference.

    * *     Configure the App to disable Lazy Loading      * *

    -> in './app/Providers/AppServiceProvider.php' lies all the control to configure your application. In the 'boot()' function, which loads after all the dependencies have been loaded, we introduce the code to disable lazy loading .

    ``` ./app/Providers/AppServiceProvider.php

           public function boot(): void
               {
                   Model::preventLazyLoading();  // this line disables the lazy loading
               }

    ```

    # now an error will be thrown if application does the lazy loading


* Lecture 14 : Pagination *

    -> Remember in the last episode, we fetched and displayed all the records using eager loading i.e. ``` Job::with('employer')->get(); ```. 'get()' will fetch all the records. In our case, we had only 10 or so records. But in real life, the records can be in millions. In those cases, running the 'get()' method will cause memory issues by fetching those million records and storing them in memory. This problem is solved using 'paginate()' in place of 'get()'. Moreover, we can give the number of records to display per page as argument to 'paginate()' method. Here's the modified code:
        $jobs = Job::with('employer')->Paginate(3);  // 3 records will be shown per page

        -> Now, we'll also introduce pagination links to navigate to next or previous pages. It's ridiculously easy:
            ``` jobs.blade.php

                // introduce:
                <div>
                        {{ $jobs->links() }}
                </div>

            ```

        * *     Load the Pagination vendor into the application directory       * *

            -> By-default, the Laravel is using TailwindCSS to style the pagination links. It also supports other tools and libraries like Bootstrap etc.
            -> The markup or styling of the pagination links is stored in Pagination package which is a vendor package. The vendor package files need to be loaded into the application files to modify them.
            -> Let's load these files:
                ``` php artisan vendor:publish ```

                # vendor: any package loaded by composer,   # publish: we want to load the vendor
                # select the Pagination, and it will load that in /resources/view/vendors/Pagination

            -> To change the default settings and setting up bootstrap to style pagination links, we'll need to configure our app

                ``` ./app/Providers/AppServiceProvider.php

                        # introduce this line to the boot():
                            \Illuminate\Pagination\Paginator::useBootstrap();
                            OR
                            \Illuminate\Pagination\Paginator::defaultView('view_name');

                ```

                -> ' ./resources/views/vendors/pagination/tailwind.blade.php ' is the file to tweak if we want to change the default styling.

        !!!!!     Issue with the Pagination       !!!!!

            -> If you have millions of records, you'll need numerous pages to show them. It might take some time to calculate those page each time user navigate back and forth. This issue can be solved using

                (i) Simple Navigation Links
                 i.e. let's not display the page number and only show the 'Previous' and 'Next' button. This is done by simply changing '->paginate(3)' to '->simplePaginate(3)' :

                 ``` web.php

                    Route::get('/jobs', function () {
                    //    $jobs = Job::with('employer')->paginate(3);
                        $jobs = Job::with('employer')->simplePaginate(3);


                        return view('jobs', [
                            'jobs' => $jobs
                        ]);
                    });

                 ```

                 # it fetches the record from database and then show the record with offset value depending on the record argument to ->simplePaginate(3).

                 (ii) Cursor base Pagination

                    change '->simplePaginate(3)' to '->cursorPaginate()'

                    # it has a caveat that if you hover over next or previous button, the page will show the link which will be the link of the record to fetch. It longer says that 'go to the form and page number #' but rather it will show the link of the record. Usually you don't want to display links but areas like infinite scrolling, you might like to fetch record using that record's link.

                    # It fetches the record by storing the starting location of the next set of results.


* Lecture 15 : Database Seeders *

    -> If you run ``` php artisan migrate:fresh ``` it'll drop all of your tables and rebuild them from scratch. And now you'll have to manually populate the records in the database.
    -> We have been populating dummy records into the database using the factory().
    -> The issue with factory is we will have to run the darn command for each table in php artisan tinker.
    -> Instead we can seed the database with dummy record, and we'll have to run only single command to seed the database.

        php artisan migrate:fresh ```  and then ``` php artisan db:seed ``` ```

            OR COLLECTIVELY

        ``` php artisan migrate:fresh --seed ```

        # it says, drop all the tables and rebuild them and seed the database with records.

        # the seeder is present in ./database/seeders/DatabaseSeeders.php


        -> Till now, we have been seeding the database with a single user. Let's seed the database with multiple jobs. Keep an eye on database constraints tho (e.g. unique emailID of each user)
        -> test@example is already in the database, so if you run ``` php artisan db:seed ``` there will be violation of UNIQUE constraints. So, make sure to fresh the database before seeding so these constraints are not violated. You can run this to avoid constraints violation:

            ``` php artisan migrate:fresh --seed ```

           -> Before that let's create a job factory:

           ``` ./database/seeders/DatabaseSeeder.php

               use App/Models/Jobs;   // make sure to include this

               run(){
                    Job::factory(100)->create();
               }

           ```

    * *     Making a New Seeder     * *

        -> You can have different seeder classes for different tables so you can
        i) run these classes in isolation so you would not have to build all the tables just to build one specific table.
        ii) create dedicated seeders for constructing the whole world for a test. This can help in case you want to run particular test.

        For example you can have a seeder class JobSeeder
        -> ``` php artisan make:seeder ```
            -> give the name of the seeder
            -> Place the code to seed the database

            -> To run this class with your root seeder class, introduce the following in 'DatabaseSeeder.php'
                ``` $this->call(JobSeeder::class); ```

        -> If you want to run the specific seeder class and not the default seeder class (i.e. DatabaseSeeder.php), run

            ``` php artisan db:seed --class=JobSeeder ```


    * *     Difference between Factories and Database Seeder     * *

        -> Factories : used to quickly scaffold data and prepare test.
        -> Database seeder : give us a class that we can trigger to run one or more factories or calls. Seeder doesn't have to always trigger a factory. It can also make direct database calls. It can reach to Eloquent directly. It just they usually reach for factories because factories are incredibly easy to prepare.


* Lecture 16 : Forms and CSRF *

    -> let's build a 'create job' page. The route, conventionally should be '/jobs/create' but it will conflict with the wild-card '/jobs/{id}' that happens to be above this. To avoid this, make sure the wild-cards are declared close to the bottom. So, declare '/jobs/create' route before
    '/jobs/{id}'.

    * *     File Handing & Directory Management     * *

        -> Inside view, create a directory 'jobs' which has the following files with modified view files.
            'index.blade.php'       =>      to show all the jobs            => return view(jobs.index, // other code)
            'show.blade.php'        =>      to show a single job            => return view(jobs.show, // other code)
            'create.blade.php'      =>      to show job creation form       => return view(jobs.create, //other code)

        -> Notice, we have used dot notation '.' in web.php return view(). You can go with '/' as usual.

        -> add method and action to the form to make a post request as :
            ``` <form method="POST" action="/jobs"> ```

            -> since our route for post request is not defined, let's do that in 'web.php'. Keep in mind, we are making a post request now:

                ``` web.php

                    // Post request from Create Job form
                    Route::post('/jobs', function () {
                        dd("Hello from the post request");
                    });

                ```
                # It'll display '419 | PAGE EXPIRED' page. Let's dig into that.

    * *     Cross Site Request Forgery CSRF     * *

        -> The '419 | PAGE EXPIRED' error refers to the automatic security measure by laravel for Cross Site Request Forgery.

        -> Suppose you get a request from you bank to update the password, the update password form looks like it is form the local bank but it is actually from a hacker. You type in and update your password. The form will make a post request to the local bank database but hacker was able to intercept your data and will use this password for malicious activities. This is the Cross Site aspect of this forgery.

        -> How will the localBank let you update password? You might had signed in in your account hours ago, or last night and the session cookies are still in browser. When you make a POST request, these cookies will be read and it will let you update the password.
        -> Now, you password has gone to the hacker.

        * * *       How to Fix CSRF?       * * *

            -> This problem is fixed by leveraging the use of a 'token' which will be included as part of form .

                <input
                    type="hidden"
                    name="name"
                    value="AXQ0ajfscneaN10"
                >

            -> Now, we will compare this token (i.e. part of form) with the token that is stored in your browser in current session.

                <?php

                    if($token !== $session->token()) {
                        // Tokens do not match!
                        // Show 419 error page.
                    }

            -> If those match, then things are probably legit.

            * * *       @csrf Directive     * * *

                -> To apply fix of CSRF in your form, introduce this:

                    ``` <form method="POST" action="/jobs">
                            @csrf

                         # @csrf will be compiled down to Vanilla PHP and laravel will take care of the rest.
                         # csrf will be shown as hidden input with token value. You can confirm that by inspecting the page.

                             ``` <input type="hidden" name="_token" value="Yj2CQJdhlR5jVso3HtyrJ0MxwAsvUIayeOg195xK" autocomplete="off"> ```


                -> Now, if tokens match, the post request will be made.

    * *     Extracting the Form Attributes from a Post Request     * *

        -> When post request is made, we need to extract some attributes ('title' and 'salary' in this case) from POST request, so that we can store those attributes in the database. We can get the attribute by using 'request()->all()';

            ``` web.php

                // Post request from Create Job form
                Route::post('/jobs', function () {
                    dd(request()->all());
                });

            ```

            # you can get a specific attribute by passing it's name as an argument to the 'request()'.
                ``` request('title');

        -> Let's store the attributes in the database using 'create()' request.

            ```web.php

                // Post request from Create Job form
                Route::post('/jobs', function () {

                    Job::create([
                        'title' => request('title'),
                        'salary' => request('salary'),
                        'employer_id' => 1
                    ]);

                    return redirect('/jobs');
                });

                # notice we hardcoded 1 as employer_id because we haven't touched upon authentication yet. We assume the employer is an authenticated user.

                # make sure to add 'employer_id' in the '$fillable' fields in Job Model so we can mass assign it.

        -> Now our job will be listed at the last page. We want latest jobs to be shown first. We can leverage 'latest()' which run SQL ORDER_BY clause and order the records on the bases of 'time at which they were created'. Introduce this function where we are doing the pagination to list all the jobs.

            ``` web.php

                Route::get('/jobs', function () {
                    $jobs = Job::with('employer')->latest()->simplePaginate(3);

            ```

    * *     Fillable Fields and Guarded Fields     * *

        -> $fillable : those fields that we can mass assign.
        -> $guarded : guarded fields that we don't want to be mass assigned.

        # To avoid the hassle of declaring each field in the $fillable which you want to mass assign. You can define the fields which you don't want to be guarded. In other words, you can declare that you want all the fields to be mass assigned.
         !!! Do this only when you are aware of potential damage. !!!

            $fillable = [
                // all the fields
            ];

            OR

            $guarded = [];

            # You will have to declare one of this statement in all your MODELS.

* Lecture 17 : Valid User Input *

    -> add a "create job" button to the layout file.

    -> create a button component so we don't have to duplicate code and write all the CSS classes if we want to use any button next time:

        ```./resources/views/Components/button.blade.php

            <a  {{ $attributes->merge(['class' => "relative inline-flex items-center px-4 py-2 ml-3 text-sm font-medium text-gray-700 bg-white border border-gray-300 leading-5 rounded-md hover:text-gray-500 focus:outline-none focus:ring ring-gray-300 focus:border-blue-300 active:bg-gray-100 active:text-gray-700 transition ease-in-out duration-150 dark:bg-gray-800 dark:border-gray-600 dark:text-gray-300 dark:focus:border-blue-700 dark:active:bg-gray-700 dark:active:text-gray-300"]) }}> {{ $slot }}</a>

            # and then use it anywhere as
                <x-button href="/jobs/create"> Create Job </x-button>

        ```

    * *     Implement Validation        * *

        -> Now we'll validate the form before submitting it. Because we have some database constraints that must be followed (e.g. title can't be null).

        -> Browser side validation can be implemented by 'introducing "required" attribute in the input field' so that user can't submit a null field.
            -> This can be bypassed and user can submit an empty form by using CLI. So, we must need to implement Server Side Validation.

        * * *       Server Side / Laravel Validation      * * *

            -> To implement server side validation, we just need to use 'request()->validate($attributes)' as follows:

                ```web.php

                    Route::post('/jobs', function () {

                        // validate the attributes

                        request()->validate([
                            'title' => ['required', 'min:3'],  // title is required and should be more than three characters
                            'salary' => ['required']
                        ]);

                        // if this validation fails, user will be automatically redirected to form again and laravel will pass an $error[] which contains all the attributes which failed the validation

                        Job::create([
                            'title' => request('title'),
                            'salary' => request('salary'),
                            'employer_id' => 1
                        ]);

                        return redirect('/jobs');
                    });

                ```
                 # if validation fails, the page will look like it refreshed and laravel will send back an error array containing the attributes that failed the validation.

                 # $errors[] is always available for you. It maybe empty but it's available all the time.


            -> let's display errors in 'create.blade.php':

                ```
                {{-- display validation errors:--}}
                    @if($errors->any())
                        <ul>
                            @foreach($errors->all() as $error)
                                <li>{{ $error }}</li>
                            @endforeach
                        </ul>
                    @endif

                ```

            -> let's display error below each input field:

                @error('title')
                    <p class="text-xs text-red-500 font-semibold mt-1"> {{ $message }}</p>
                @enderror


                # $message contains the error message and is available only in @error directive

                # this is some inline server side validation in action.
                # also implement client side validation ('required' attribute) for better user experience.

    -> go to ' https://laravel.com/docs/11.x/validation ' to know more about validation rules.


* Lecture 18 : Editing, Updating and Deleting a Resource *

    -> add an 'Edit Job' button to the single job page

    -> the route to the "job edit" form will be '/jobs/{id}/edit' and the 'view' will be 'jobs.edit'. Let's do this :

        ```web.php

            // Edit a job
            Route::get('/jobs/{id}/edit', function ($id) {
                $job = Job::find($id);

                return view('jobs.edit', ['job' => $job]);

            });

        ```

        -> when we go to the specific job page to edit it, we'll want the attributes must be auto-populated in 'title' field and 'salary' field. Do this:
            <input
                type="text"
                name="title"
                id="title"
                class="block min-w-0 grow py-1.5 pl-1 pr-3 text-base text-gray-900 placeholder:text-gray-400 focus:outline focus:outline-0 sm:text-sm/6" placeholder="Shift Leader"
                value="{{ $job->title }}"  // value will populate the title in the title field
                required>

             # same for salary

            <input
                type="text"
                name="salary"
                id="salary"
                class="block min-w-0 grow py-1.5 pl-1 pr-3 text-base text-gray-900 placeholder:text-gray-400 focus:outline focus:outline-0 sm:text-sm/6" placeholder="$50,000 USD / Year"
                value=" {{ $job->salary }}"
                required>

        ```

    -> By default, the browser only understands GET and POST request. However, framework can understand more requests, such as :
        i) Patch : set of instructions on how to modify a resource
        ii) Delete : destroy a resource.

        -> with the same URI (i.e. '/jobs/{id}') and changing request type, we can modify or destroy a resource as:

            ```web.php

                // Edit Job
                Route::patch('/jobs/{id}', function ($id) {

                    // validate the request
                    request()->validate([
                        'title' => ['required', 'min:3'],  // title is required and should be more than three numbers
                        'salary' => ['required']
                    ]);

                    // authorization ( ....On hold)

                    // update the job

                    $job = Job::findOrFail($id);  // findOrFail() : won't proceed if the job is null

                    $job->update([
                        'title' => request('title'),
                        'salary' => request('salary')
                    ]);

                    // OR

                    /*
                    $job->title = request('title');
                    $job->salary = request('title');
                    $job->save();
                     */

                    // redirect to the specific page
                    return redirect('/jobs/' . $job->id);

                });

                // Delete Job
                Route::delete('/jobs/{id}', function ($id) {

                    // authorize (... on hold)

                    // delete the job
                    Job::findOrFail($id)->delete();

                    // redirect
                    return redirect('/jobs');
                });



    -> Since browser doesn't understand the PATCH request, we have to signal the framework on form submission that we made 'POST' request because we had to but actually we want to make a PATCH request. We can hint the framework by using a directive:

        <form method="POST" action="/jobs/{{ $job->id }}">
                @method('PATCH')


    * * Handling Delete Request * *

        -> We'll add a delete button below the edit page. We can not have a form within a form. So we'll declare our delete button in PATCH request / edit job form but point the delete button to trigger a DELETE request form.

        ``` <div  class="flex items-center ">
                <button form="delete-form class="text-red-500 text-sm font-semibold">Delete</button>
            </div>

        ```

        -> Now, declare another form and trigger the form method with the delete button by passing form id as attribute to the delete button

        ```
            <form
            method="POST"
            action="/jobs/{{ $job->id }}"
            id="delete-form"
            class="hidden">

                @csrf // authentication
                @method('delete') // indicate that this is delete request

            </form>

        ```


* Lecture 19 : Routes Reloaded *

    * *     Route Model Binding     * *

        ```
            Route::get('/jobs/{id}', function ($id) {
                // grab the job which has id equals to the user requested id
                $job = Job::find($id);

                // load the view
                return view('jobs.show', ['job' => $job]);

            });

        ```

        -> In above code, you are finding an id from the jobs page and then calling the Job model to give you the instance of the job. You will need to do that again and again. Luckily, Laravel has a short-hand for that if you follow the common convention.
        -> We can rewrite the above code as:

        ```
           // Show
           Route::get('/jobs/{job}', function (Job $job) {
               return view('jobs.show', ['job' => $job]);
           });

           # notice the '{job}' placeholder and also passing a Job instance to the anonymous function.
           # your wild card '{job}' and parameter name '$job' need to be same.
           # then we signal the laravel that we don't need the string in the job but a 'Job' instance.
           # it doesn't always have to be '{job}'. It's just the unique identifier in the database. In our case it was 'job_id' so we got the job id.
           # in your case, it can be any slug or anything. You can specify the unique identifier as the following:

               Route::get('/jobs/{posts:slug'}  // leave it off to stick with defaults
        ```

    * *     Controller Classes     * *

        -> Developers have dedicated controller classes for handling specific tasks such as 'Routing'.

        ```
            php artisan make:controller
                > name_of_controller -> JobController
                > type_of_controller -> Empty


            # path -> ./app/Http/Controllers/JobController.php

        ```

        -> in JobController, create methods for each task like 'index()' 'show()' 'edit()'.
        -> Let's simplify routing by making the Route call to the corresponding method in the JobController when the user visits a specific route/page.
        -> Example: implement in the JobController method 'index' to show user something every time the user visits the jobs page.

        ```JobController.php

            public function index(){
                    dd('hello');
                }

        ```

        -> Tweak the route file to call this method when a user visits job page.

        ```web.php

            # this is the old code :
            // Index
            Route::get('/jobs', function () {
                $jobs = Job::with('employer')->latest()->simplePaginate(3);

                return view('jobs.index', [
                    'jobs' => $jobs
                ]);
            });

            # it can be replaced with our new code to call the corresponding method in the specific controller.

            // Index
            Route::get('/jobs', [JobController::class, 'index']);

            # cut the content from old route to index jobs page and place it in the 'index()' in JobController

              ``` JobController.php

                    public function index(){
                        $jobs = Job::with('employer')->latest()->simplePaginate(3);

                        return view('jobs.index', [
                            'jobs' => $jobs
                        ]);
                    }

                    # new 'index()' method.

        # Do this for all actions of JobController

    * *     Route::view()     * *

        -> There'll be cases when, in response to the 'get()' request, you will not do anything but return just a view like home page, contact page or about page. In such case you can use this shorthand method of laravel.

         ``` Route::view('/', '<view_name>');

         ```web.php

            Route::get('/', function () {
                return view('home');
            });

            Route::get('/contact', function () {
                return view('contact');
            });

            # above code can be replaced by the following code:

            Route::view('/', 'home');
            Route::view('/contact', 'contact');

    * *     Listing Your Routes     * *

         In normal projects, you might have hundred or routes. To list down all of your routes, use:
            ``` php artisan route:list ```

         -> To list all the routes except vendor routes
            ``` php artisan route:list --except-vendor ```

            # it will list the routes and corresponding views or actions in JobController resource and also request type on each route.

    * *     Route Groups     * *

        -> If you noticed in the web.php, we were referencing to the JobController in each route. Well, let's remove the duplication and group all the routes that are referencing that controller:

         ```web.php

            Route::controller(JobController::class)->group(function () {

                   // all the routes referencing  the JobController class
                   // e.g.
                   Route::get('/jobs', 'index');
                   Route::get('jobs/create',  'create');
            });

    * *     Route Resource     * *

        -> We have now build a collection of actions regarding jobs in the 'web.php'. We can now just reference that resource using the 'resource()' of the 'Route' class as:
            ``` Route::resource('<resource_name>', '<corresponding_controller_name>');

        ```web.php

            # here's the resource which contains collection of actions

            Route::controller(JobController::class)->group(function () {
                // Index
                Route::get('/jobs', 'index');
                // Create
                Route::get('jobs/create',  'create');
                // Show
                Route::get('/jobs/{job}',  'show');
                // Store
                Route::post('/jobs',  'store');
                // Edit
                Route::get('/jobs/{job}/edit', 'edit');
                // Update
                Route::patch('/jobs/{job}', 'update');
                // Delete Job
                Route::delete('/jobs/{job}', 'destroy');
            });

            # this all code can be replaced with this code

            Route::resource('jobs', JobController::class);

        ```

        -> It is not necessary to stick to all the default routes. You can specify which routes you want to include or exclude from the resource by passing the names of the actions as:

            Route::resource('jobs', JobController::class, [
                'only' => ['index', 'show', 'create'],   OR
                'except' => ['destroy']
                ]);








