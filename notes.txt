``````` This is my notes file for '30 Days to Learn Laravel by Jeffrey Way  ```````

* Lecture 01 *

    -> Setting Up Herd and starting a new laravel project. Problems I faced :
        -> Uncommenting Zip command in php.ini, installing an unzipping utility and adding its path to system variables, and running a local server on my system using 'php artisan serve' command because 'laravel-project.test' wasn't working in my browser.
        -> I was Facing 'Failed to listen at 127.0.0.1:<port_number>'. I resolved it by going into C:\Users\<user>\.config\herd\php84\php.ini\ . Change `variables_order = "EGPCS"` to `variables_order = "GPCS"`.

* Lecture 02 : Your First Route and View *

    -> Adding two route paths (i.e. /about & /contact) in the /routes/web.php and building corresponding rendering pages (view) in /resources/views/...

* Lecture 03 : Create a Layout File *

    -> update about.php, contact.php to 'about.blade.php' and 'contact.blade.php' . Think of Blade as an extra layer on top of php which gives you some goodies, some helper methods and some shortcuts. (like tailwind CSS on top of CSS)

    -> Make /views/Components/layout.blade.php and past the layout HTML (which is common to all pages) in that so we don't have to write same darn HTML in each web-page.

    -> We don't want to paste our basic html layout code in every page's file (home,about, contact). So we paste it in a layout file and the reference it as a custom html tag. Since our file name is layout, so to reference it we use:

        <x-layout>
            <h1> Content which is unique to every page </h1>
        </x-layout>

        use of word x is just to make the tag unique and making sure we aren't using already existing tag.

    -> In layout file, we must tell the file that we want to past some unique content in the corresponding page. So, we mark the space in the layout file using this code:

        <?php echo $slot ?>
        -> 'Slot' is a reserved keyword in Laravel.

        -> Since we are using Blade, so '{{ $slot }}' will be equivalent to <?php echo $slot ?>

	** HOME WORK **

    -> extracting nav link in a file :
        - extract nav link in a file /views/Components/nav-link.blade.php
        - use {{ $attributes }} in place of 'href=""', since we are going to make it dynamic and link will be unique for each page.

        ```laravel

	    ./project/resources/views/Components/nav-link.blade.php~
        <a {{ $attributes }}> {{ $slot }} </a>

	    ./project/resources/views/Components/layout.blade.php~
        and <x-nav-link href="/page-route"> Page Name </x-nav-link> in the layout file.

        ```
* Lecture 04 : Pretty Layout TailwindCSS *

    -> {{ $attributes }} can be 'href', 'id', 'class' etc.
    -> What to do if you have more than one slots to be filled dynamically.
        - suppose the variable name in the layout page is $heading. In the corresponding route page, you can write as

        <x-slot:heading> Variable Dynamic Name </x-slot:heading>

            -> In this way i.e. by using the name of the slot, we specify the slot we are going to target.

    -> Navigation Links are little different and usually more complex from ordinary anchor tags. For example, we show different color for an active nav. So, you must keep nav links in separate file to remove the complexity from general file.

* Lecture 05 : Style Active Nav Link *

    -> We are going to add some custom styling and some code to highlight the active link.

    * *     request()    * *
        -> we used a method 'request()'. This helper method is used to grab information about the "CURRENT REQUEST" .

        -> This helper method has another method 'request()->is('expression')' which takes an expression and tells if the given expression matches the current page.
            -> request()->is('about') will return true if we are on 'about' page.

    * *     Aria Current     * *

       aria-current="page"
       -> This HTML attribute is used by screen readers, and it tells the user who has vision impairment whether the active nav link is current page or not.

    * *     Attributes and Props     * *

        Attributes -> refer to HTML attributes like 'id', 'class', 'href' etc.

        Props (Property) -> is anything that is not an attribute. You must know about them so not to include them as attribute of a tag.
            -> If you have a prop of name 'active' like :
            <a href="#" id="foo" active="uh-oh">
               now you have an anchor tag with an attribute 'active'. And that doesn't make sense. So Props should be distinguishable from HTML attributes.

        -> The attributes are rendered with the html page and can be seen when you inspect the page, however you can not see the props when you inspect a webpage using developer tools.

    * *     Blade Directives     * *

        -> Directives in Blade start with '@'.
        -> Directives can be @dump, @foreach, @if, @Props and
        -> @props directives are usually initialized on top in a file .
        -> They are ultimately compiled down to Vanilla PHP echo statements or function calls.

        -> Props (properties) are usually declared as array. If we don't declare Props, browser will render them as normal HTML attributes. (you can confirm by inspecting the webpage).
        -> props are passed as variables.

            @props(['active' => false])

            <a $active >Home</a>

        -> Must initialize props with some value so if anything fails, that default value is used.

        -> With laravel or blade, sometimes false is treated as "false" i.e. expression false is treated as string false.
        How to solve this?
        Put a semicolon : before a prop to indicate that the given value is an expression and not the string like:

            <x-nav-link href="/" :active="false">Home</x-nav-link>

        -> You can use PHP directive to execute php code as:

            @php
                // some php code
            @endphp

        * *     HOME WORK     * *

            -> creating a new 'type' props and apply if-statement if the type is button or anchor tag. Code for homework

                @props(['active' => false,
                    'type' => 'a'
                ])

                @if($type === 'a')
                    <a {{ $attributes }}  class=" {{ $active ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white' }} rounded-md px-3 py-2 text-base font-medium " aria-current=" {{ $active ? 'page' : 'false' }} ">{{ $slot }}</a>
                @else
                    <button {{ $attributes }}  class=" {{ $active ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white' }} rounded-md px-3 py-2 text-base font-medium " aria-current=" {{ $active ? 'page' : 'false' }} "> {{ $slot }} </button>
                @endif


* Lecture 06: View Data and Route Wildcards *

    -> In routes file, you can pass an array to the 'view()' along with the route. And, then you can access that array of variables in corresponding view file.

    ``` laravel

        ./routes/web.php
        Route::get('/', function () {
            return view('home', [
                'greeting' => 'Yo',
                'name' => 'Larry Nickolas'
            ]);
        });

        ./resources/views/home.blade.php
        <h1> {{ $greeting }} from the Welcome page. My name is {{ $name }} </h1>

    ```

    ->  Let's do something complex, suppose we have to list down jobs on our home page. So we can pass an array which will contains jobs and each job will have properties like 'Job Title' and 'Salary' etc.

    ``` laravel

    Route::get('/jobs', function () {
        return view('jobs', [
            'jobs' => [
                [
                    'id' => 1,
                    'title' => 'Director',
                    'salary' => '$50,000'
                ],
                [
                    'id' => 2,
                    'title' => 'Programmer',
                    'salary' => '$10,000'
                ],
                [
                    'id' => 3,
                    'title' => 'Teacher',
                    'salary' => '$40,000'
                ]
            ]
        ]);
    });


    ./resources/views/jobs.blade.php
            @foreach( $jobs as $job)
                    <li><strong> {{ $job['title'] }} : </strong> Pays {{ $job['salary'] }}</li>
            @endforeach

    -> Let's change the about page to the job page and shift this job listing to that and make our home page simple and clean.
    -> We need to change 'about.blade.php' to 'jobs.blade.php', change the nav-link in the 'layout.blade.php' file. tweak the view method in the ./routes/web.php to include the 'jobs[]'.
    -> 'about' page is now converted into 'jobs' page.

    * *     Routing to Specific Job Page    * *

        -> We are now going to create a specific page for each job. For that, we have included 'id' as property so each job is identifiable, and we can route to that specific job page using '/jobs/{id}'

        -> Turn the list items on jobs page into links using anchor tags.

        * * *   How Do We Create a Route that Listens for /jobs/<some_dynamic_value> ?  * * *

            -> Let's create a route in /web.php

            ```

            Route::get('/jobs/{id}', function ($id) {
                dd($id);
                return view('contact');
            });

            ```
            -> Laravel has cool thing. It will automatically detect that if something is enclosed in curly braces, it is some 'wildcard' character, and then you can pass it to any function to use it as you like.

            -> now if you put url example.test/jobs/1
                => dd($id) will give you value 1.
            -> likewise for 2 and 3.

            -> notice {id} was a wildcard, laravel did all the work of grabbing it, isolating it and then passing to the callback function/closure.

        * * *   Create a Route for Each Job Page  * * *

            -> We can do this by passing all the jobs to the callback function in the Route::get() and then return the view where $id will be equal to user requested job id.

            -> instead of running a foreach loop on each array item, leverage Laravel framework and use Arr::method() which is gonna give a number of methods to be run on array items.

            -> use the first() method to find the first item in the array which matches the given criteria

                ```

                $job = \Illuminate\Support\Arr::first($jobs, function($job) use ($id) {
                       return $job['id'] === $id;
                });

                // load the corresponding view
                return view('job', ['job' => $job]);

                ```

                OR

                ```

                $job = \Illuminate\Support\Arr::first($jobs, fn($job) => $job['id'] == $id);

                // load the corresponding view
                return view('job', ['job' => $job]);

                ```
            -> This code says, look in the $jobs array, grab each item as $job and return true if the value of 'id' property of that job equal to given value of the id.

            -> Create a corresponding job.blade.php and leveraging $job variable, print the job details

            -> href="" for the job page will become

            ``` /jobs.blade.php

            <ul>
                @foreach( $jobs as $job)
                        <a href="/jobs/{{ $job['id'] }}" class=" hover:underline">
                            <li><strong class="text-blue-500"> {{ $job['title'] }} : </strong> Pays {{ $job['salary'] }}</li>
                        </a>
                @endforeach
                </ul>

            ```


* Lecture 07: Auto loading and Models *

    -> In the previous lecture, we did the duplication of 'jobs' array in two routes (i.e. '/jobs' and '/job') in '/web.php' file. Ofc, duplication is not good in code. We are going to solve this issue incrementally.

    1st Solution:
        -> declare the 'jobs' array in global scope and then use it in your functions.

        ``` web.php

        $jobs = [
            // jobs array
        ]


        Route::get('/jobs', function () use ($jobs) {
            return view('jobs', [
                'jobs' => $jobs
            ]);
        });


        Route::get('/jobs/{id}', function ($id) use $jobs {

            $job = Arr::first($jobs, callback: fn($job) => $job['id'] == $id);
            return view('job', ['job' => $job]);
            });

    2nd Solution:

        -> Extract the array and place it in a class, and then we can access the array using a public method of the class.

        ``` web.php

        class Jobs{
            public static function all(): array
                // return [ //array containing arrays of jobs]
        }

        # notices the ': array' after function declaration. This is to specify the return type of the function

        And then access it as :

            'job' => Job::all()
            and
            $job = Arr::first(Job::all(), callback: fn($job) => $job['id'] == $id);


    * *     Model - View - Controller (MVC)   * *

        USER -- uses --> CONTROLLER -- manipulates --> MODEL -- updates --> VIEW -- sees --> USER -- uses -->

        -> View : presentation layer
        -> Controllers: Handle logic and act as an intermediary between the Model and the View.

            -> It receives information from the user, process it (using models), and then return a response by rendering a view or redirecting to another page.
            ->Like in 'web.php', we define routes, and then we define a function that handles that route is a controller.

        -> Model: Represents data and  the business logic tier of your application.
            -> Models are used to interact with database and define relationship between tables.

            -> In case of Job Board Platform:
            -> Think of all the behaviors associated with the job. For example:
                => What are the rules for creating a job?
                => Can jobs be marked as opened or filled? What happens when a Job is filled?
                => This does account for how do you store the jobs, do you write them to a file?
                => How to remove or archive a Job?

            -> All of the above stuff can be encapsulated under the umbrella of MODEL.

            -> Now we are going to put 'Job' class (which we made in the previous lesson) into our Model directory.

    * *     Namespaces in Laravel/PHP   * *

        Namespaces are used to organize and group classes, functions, or constants to avoid naming conflicts.
        For example, if you have two files with same name 'User', you can place them in different namespaces to avoid conflicts.

    * *     Making a new function find()    * *

        -> How about if we extract the code to find the job with the given id and encapsulate it into a 'find()' method of job class? We're going to do that

        ```Job.php

            public static function find(int $id): array
                {
                    return Arr::first(static::all(), callback: fn($job) => $job['id'] == $id);
                }

        ```

        -> and just call that find() in web.php as :

        ``` web.php

            Route::get('/jobs/{id}', function ($id) {
                // grab the job which has id equals to the user requested id
                $job = Job::find($id);

                // load the view
                return view('job', ['job' => $job]);

            });

        ```


    * *     Should We Declare Datatypes     * *

        -> In case of errors, they'll point to a place where things are potentially easy to handle. And won't direct you to confusing parts of the code.
        -> in simpler words, points to the root cause where things will be comparatively easy to handle.

    * *     Declare Unhappy Path    * *

        -> Suppose user access a job with id which is not in our database, we must show user a 404 Page-Not-Found errors page.


* Lecture 08: Introduction to Migrations *

    -> .env file in your project directory is where your Preferences, passwords, database information is saved.
    -> Artisan in a Laravel Herd project is a powerful CLI tool used for tasks like code generation, database migrations, testing, cache management, and more.

    -> If you didn't create project using CLI, you might don't have the file './database/database.sqlite'. You can run following command to create a new database:
        php artisan migrate

    * *     Connect to a Database     * *

        -> You can do this using CLI.
        -> If you want to do this using a GUI:
            -> install TablePlus -> create an SQLite connection -> give database name -> connect to the database file in your project directory -> connect

        -> The logic to create database tables is locked in PHP. When you create the database or run 'php artisan migrate', it runs the migrations stored in './database/migrations/*.php'. You can think of the files in this directory as Blueprints for table. If you make changes to files in this directory, you'll need to "run migrations" in order to display those changes in the database. You can add, reset, rollback changes using migrations (likev version control).


    * *     Migrations     * *

        -> Consider if your team member will have to construct a database same as yours. It'll be a nightmare if the database is big. One little mistake would cost a lot. Migration solves a big issue.
            -> You just need to share these Migration files in '/database/migrations/*.php' with your teammate, and he just needs to run a single command to generate a database same as yours. The command is
                php artisan migrate

        -> You can have migration to drop a table, or to create a table, or to add a couple of columns to the table.

        -> # # THINK OF MIGRATIONS AS ACTIONS YOU WANT TO PERFORM ON DATABASE. # #

        -> To list down command related to database, use:
            php artisan

            * * *   Making Changes to Migrations    * * *

                -> in 'create_users_table.php', in users table, change the name to first_name and add another column of last_name.

                -> If you change anything in migration files, run the command to make changes effective:
                    php artisan migrate:fresh

                    # This will drop all the tables and construct them from scratch according to changed 'Migration' file

                -> There's an issue with SQLite, it won't refresh until you close the connection and start the connection again.

            * * *   Creating a Job Listings Table    * * *

                -> Run the command:
                    php artisan make:migration

                -> set the table name to create_job_listings_table
                -> It will create a migration file in the /migrations.
                -> This file will have two Methods i.e. 'up' and 'down'. 'up' is for applying any operation,  adding things and removing things.
                -> 'up()' is for doing the thing and 'down()' is for undoing the thing.

                * * * *     Creating new columns    * * * *

                    ->add two columns in the job_listings table :
                        $table->string('title');
                        $table->string('salary');

                    -> run the following to make changes effective:
                        php artisan migrate

                        # This will migrate only the new changes from Blueprint(i.e. migrations file) and to the table

                    -> Populate data we were hard coding manually into the database 'job_listings' table.


* Lecture 09: Meet ELOQUENT *

    -> Laravel ORM is called Eloquent. An ORM is 'Object-Relational Model'. It helps to interact with database in object-oriented way.
    -> Eloquent automatically writes the PHP code you write into SQL queries. Helps you by not letting you write complex SQL queries.
    -> Eloquent maps a row in your database table into a PHP Object. Thus, makes handling data easier for you.

    * *     How to convert a Class into Eloquent Mode   * *

        -> import the Eloquent class:
            use \Illuminate\Database\Eloquent
        -> change the class name to:
            class Jobs extends Models{}

    -> Eloquent relies heavily on 'convention over configuration'.
    -> The Eloquent model name or class name should be 'singular form' of your table name. For example, if your table name in the database is "comments", your Eloquent model name or class name should be 'Comment'. Similarly, if your table name in database is 'posts', your Eloquent model name should be 'Post'.

    -> If your Eloquent Model name is Jobs and your table name is job_listings. You can do:
        1st -> change the model name to JobListing
        2nd -> in class, you can declare this
            protected $table = 'job_listings';

    -> show the jobs on the page using Job::all() as:

        ``` web.php

            use App\Models\Job;

            Route::get('/', function () {
                $jobs = Job::all();

                dd($jobs);

            //    return view('home');
            });

        ```

        -> In order to grab first job, use '$job[0]';
        -> In order to grab first job's any specific property, use '$job[0->title]';


        -> Get rid of the above route, and restore to original home route.

    -> Because of 'Job::all()' in our jobs view. The jobs will be listed down but this time they are being fetched from database, and we don't have to hard code them.

    * *     PHP Artisan Tinker   * *

        -> `php artisan tinker`
            ->this command will give you a playground shell to test your code, make and verify variables, create tables, users.

        -> in tinker, run this:
            > App\Models\Job::create(['title' => 'Acme Director', 'salary' => '$1,000,000')];

        -> Laravel will give you MassAssignmentException.
            > Mass Assignment is practice of assigning values to multiple model attributes at once, typically through an array.
            -> Let's dig into that. Usually it's in hands of users to update values such as title or salary. We believe users are malicious. If a user requests to change the title of a post and somehow tweak the form request to change the author-id of the post or admin status of a user or admin. That can be catastrophic. To avoid this, Laravel by-default protects you from assigning values to the attributes that are not explicitly allowed for mass assignment.
            -> Laravel protects you from accidentally assigning values to attributes that shouldn't be changed directly by the user, such as sensitive fields like password, is_admin, or id.
            -> You can either turn this feature off or do the following:

                -> explicitly allow attributes to be mass assigned:
                    ```

                        class Jobs extends Models{
                            $protected $fillable = ['title', 'salary'];
                        }

                    ```

                    -> Now, if the user tries to change the id, the request will be ignored.
                    -> close the tinker, re-open it and re-run the command to create a new job and now it works.

                    -> inspect all jobs
                        ``` Apps\Models\Job::all(); ```

                    -> to find a specific record in the database table. (the record must have a unique identifier)
                        ``` Apps\Models\Job::find(id); ```

                    -> to delete the job:
                        $job = App\Models\Job::find(id);

                        $job->delete();

    * *     Creating Models and Migration using php artisan   * *

        -> ` php artisan make:model <model-name> `
            -> this command will create a new Model in the /Models/ .

        -> ` php artisan make:model <model-name> -m `
            -> this command will create a new Model in the /Models/  with corresponding Migration.



